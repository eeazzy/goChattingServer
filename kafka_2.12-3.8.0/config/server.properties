# Apache 소프트웨어 재단 (ASF)에 의해 하나 이상의 기여자 라이선스 계약에 따라 라이선스가 부여되었습니다.
# 이 작업의 저작권 소유권에 대한 추가 정보는 NOTICE 파일을 참조하십시오.
# ASF는 Apache License, 버전 2.0("라이선스")에 따라 이 파일을 사용하도록 라이선스를 부여합니다.
# 라이선스를 준수하지 않으면 이 파일을 사용할 수 없습니다.
# 라이선스 사본은 다음에서 확인할 수 있습니다:
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# 관련 법률에 의해 요구되거나 서면으로 동의하지 않는 한, 라이선스에 따른 소프트웨어는 "있는 그대로" 배포되며,
# 명시적이거나 묵시적인 어떠한 보증도 제공되지 않습니다.
# 라이선스에 따른 권한과 제한에 대한 자세한 내용은 라이선스를 참조하십시오.

#
# 이 구성 파일은 Apache ZooKeeper가 필요한 ZK 기반 모드에서 사용하도록 설계되었습니다.
# 자세한 내용과 기본값은 kafka.server.KafkaConfig를 참조하십시오.
#

############################# 서버 기본 설정 #############################

# 브로커의 ID입니다. 각 브로커마다 고유한 정수로 설정해야 합니다.
broker.id=0

############################# 소켓 서버 설정 #############################

# 소켓 서버가 수신 대기하는 주소입니다. 설정하지 않으면 호스트 이름은
# java.net.InetAddress.getCanonicalHostName()의 값과 같으며, PLAINTEXT 리스너 이름과 포트 9092가 사용됩니다.
#   형식:
#     listeners = listener_name://host_name:port
#   예시:
#     listeners = PLAINTEXT://your.host.name:9092
#listeners=PLAINTEXT://:9092

# 브로커가 클라이언트에 광고할 리스너 이름, 호스트 이름 및 포트입니다.
# 설정하지 않으면 "listeners"의 값이 사용됩니다.
#advertised.listeners=PLAINTEXT://your.host.name:9092

# 리스너 이름을 보안 프로토콜에 매핑합니다. 기본값은 동일하게 설정됩니다. 자세한 내용은 구성 문서를 참조하십시오.
#listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL

# 서버가 네트워크에서 요청을 수신하고 응답을 전송하는 데 사용하는 스레드 수
num.network.threads=3

# 요청 처리에 사용되는 스레드 수, 디스크 I/O 포함
num.io.threads=8

# 소켓 서버에서 사용되는 송신 버퍼 (SO_SNDBUF)
socket.send.buffer.bytes=102400

# 소켓 서버에서 사용되는 수신 버퍼 (SO_RCVBUF)
socket.receive.buffer.bytes=102400

# 소켓 서버가 수락할 최대 요청 크기 (OOM 보호)
socket.request.max.bytes=104857600


############################# 로그 기본 설정 #############################

# 로그 파일을 저장할 디렉토리 목록 (쉼표로 구분)
log.dirs=/Users/kimhyeonseo/Desktop/inflearn/golang_chat/kafka_2.12-3.8.0/logs/kafka-log

# 토픽에 대한 자동생성 옵션
auto.create.topics.enable=true

# 주제당 기본 로그 파티션 수입니다. 더 많은 파티션은 소비 병렬성을 높일 수 있지만, 브로커 전반에 걸쳐 더 많은 파일이 생성됩니다.
num.partitions=1

# 시작 시 로그 복구 및 종료 시 플러시에 사용할 데이터 디렉토리당 스레드 수입니다.
# 데이터 디렉토리가 RAID 배열에 있는 설치의 경우 이 값을 증가시키는 것이 좋습니다.
num.recovery.threads.per.data.dir=1

############################# 내부 주제 설정  #############################
# 그룹 메타데이터 내부 주제 "__consumer_offsets" 및 "__transaction_state"의 복제 계수입니다.
# 개발 테스트 외에는 가용성을 보장하기 위해 1보다 큰 값을 권장하며, 예를 들어 3이 적절합니다.
offsets.topic.replication.factor=1
transaction.state.log.replication.factor=1
transaction.state.log.min.isr=1

############################# 로그 플러시 정책 #############################

# 메시지는 즉시 파일 시스템에 쓰여지지만, 기본적으로는 fsync()를 통해 OS 캐시를 게으르게 동기화합니다.
# 아래 구성은 데이터가 디스크에 플러시되는 방식을 제어합니다.
# 여기에는 몇 가지 중요한 트레이드 오프가 있습니다:
#    1. 내구성: 플러시되지 않은 데이터는 복제를 사용하지 않는 경우 손실될 수 있습니다.
#    2. 대기 시간: 매우 큰 플러시 간격은 플러시가 발생할 때 대기 시간 스파이크를 유발할 수 있습니다.
#    3. 처리량: 플러시는 일반적으로 가장 비용이 많이 드는 작업이며, 작은 플러시 간격은 과도한 탐색을 초래할 수 있습니다.
# 아래 설정을 통해 전역적으로 또는 주제별로 플러시 정책을 구성하여 일정 기간 또는 N개의 메시지 후에 데이터를 플러시할 수 있습니다.

# 데이터가 디스크에 강제로 플러시되기 전에 수락할 메시지 수
#log.flush.interval.messages=10000

# 메시지가 로그에 머물 수 있는 최대 시간, 그 후 강제로 플러시됨
#log.flush.interval.ms=1000

############################# 로그 보존 정책 #############################

# 다음 구성은 로그 세그먼트 삭제를 제어합니다. 정책은 시간이 경과한 후 또는 지정된 크기가 누적된 후에
# 세그먼트를 삭제하도록 설정할 수 있습니다. 두 조건 중 하나라도 충족되면 세그먼트가 삭제됩니다.
# 삭제는 항상 로그 끝에서 시작됩니다.

# 나이로 인해 삭제 대상이 될 수 있는 로그 파일의 최소 나이
log.retention.hours=168

# 로그의 크기 기반 보존 정책입니다. 로그 세그먼트가 log.retention.bytes 이하로 떨어지지 않는 한 세그먼트가 잘립니다.
# log.retention.hours와 독립적으로 작동합니다.
#log.retention.bytes=1073741824

# 로그 세그먼트 파일의 최대 크기입니다. 이 크기에 도달하면 새 로그 세그먼트가 생성됩니다.
#log.segment.bytes=1073741824

# 보존 정책에 따라 로그 세그먼트가 삭제될 수 있는지 확인하는 간격
log.retention.check.interval.ms=300000

############################# Zookeeper #############################

# Zookeeper 연결 문자열 (자세한 내용은 zookeeper 문서를 참조).
# 이는 쉼표로 구분된 호스트:포트 쌍입니다. 각각은 zk 서버에 해당합니다. 예: "127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002".
# 또한 url에 선택적으로 chroot 문자열을 추가하여 모든 kafka znode에 대한 루트 디렉토리를 지정할 수 있습니다.
zookeeper.connect=localhost:2181

# Zookeeper에 연결하기 위한 시간 제한(ms)
zookeeper.connection.timeout.ms=18000


############################# 그룹 코디네이터 설정 #############################

# 다음 구성은 GroupCoordinator가 초기 소비자 리밸런스를 지연시킬 시간을 밀리초 단위로 지정합니다.
# 그룹에 새로운 멤버가 추가될 때 리밸런스는 group.initial.rebalance.delay.ms 값에 의해 추가로 지연되며, 최대 max.poll.interval.ms까지입니다.
# 기본값은 3초입니다.
# 여기서는 개발 및 테스트의 더 나은 기본 경험을 위해 0으로 재정의합니다.
# 그러나 프로덕션 환경에서는 3초의 기본값이 애플리케이션 시작 중 불필요하고 잠재적으로 비용이 많이 드는 리밸런스를 방지하는 데 더 적합합니다.
group.initial.rebalance.delay.ms=0
